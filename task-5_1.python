import argparse
import sys
from pathlib import Path
import datetime
import re
from typing import List, Optional, Tuple
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

NOTES_DIR = Path.home() / '.md_notes'

class Note:
    def __init__(self, filepath: Path, title: str, tags: List[str], created_at: datetime.datetime):
        self.filepath = filepath
        self.title = title
        self.tags = tags
        self.created_at = created_at

    @staticmethod
    def parse_metadata(lines: List[str]) -> Tuple[str, List[str]]:
        title, tags = '', []
        for line in lines:
            if line.startswith('# '):
                title = line[2:].strip()
            elif line.lower().startswith('tags:'):
                tags = [tag.strip() for tag in line[5:].strip().split(',') if tag.strip()]
            if title and tags:
                break
        return title, tags

    @classmethod
    def from_file(cls, filepath: Path):
        try:
            with filepath.open('r', encoding='utf-8') as f:
                lines = [next(f) for _ in range(10)]
            title, tags = cls.parse_metadata(lines)
            created_at = datetime.datetime.fromtimestamp(filepath.stat().st_ctime)
            return cls(filepath, title, tags, created_at)
        except Exception as e:
            logging.error(f'Failed to read or parse note file: {filepath} - {e}')
            raise

    def update(self, new_title: Optional[str] = None, new_tags: Optional[List[str]] = None):
        if new_title:
            self.title = new_title
        if new_tags:
            self.tags = new_tags
        self.save()

    def delete(self):
        self.filepath.unlink()
        logging.info(f'Note deleted: {self.filepath}')

    def save(self):
        content = f"# {self.title}\nTags: {', '.join(self.tags)}\n"
        with self.filepath.open('w', encoding='utf-8') as f:
            f.write(content)
        logging.info(f'Note updated: {self.filepath}')

def ensure_notes_dir():
    if not NOTES_DIR.exists():
        NOTES_DIR.mkdir(parents=True, exist_ok=True)

def sanitize_filename(name: str) -> str:
    return re.sub(r'[^a-zA-Z0-9_-]', '_', name)

def create_note(title: str, tags: Optional[List[str]]):
    ensure_notes_dir()
    if not title.strip():
        raise ValueError('Title cannot be empty')
    filename_base = sanitize_filename(title.lower().replace(' ', '_'))
    filepath = NOTES_DIR / f'{filename_base}.md'
    counter = 1
    while filepath.exists():
        filepath = NOTES_DIR / f'{filename_base}_{counter}.md'
        counter += 1

    tags_line = 'Tags: ' + ', '.join(sanitize_filename(t.lower()) for t in tags) if tags else 'Tags: '
    content = f"# {title}\n{tags_line}\n"

    with filepath.open('w', encoding='utf-8') as f:
        f.write(content)
    logging.info(f'Note created: {filepath}')

def list_notes(tag_filter: Optional[str] = None):
    ensure_notes_dir()
    notes = []
    for filepath in NOTES_DIR.glob('*.md'):
        try:
            note = Note.from_file(filepath)
            if tag_filter and tag_filter.lower() not in (t.lower() for t in note.tags):
                continue
            notes.append(note)
        except Exception as e:
            logging.error(f'Error processing note: {filepath} - {e}')
            continue
    if not notes:
        logging.info('No notes found.')
        return
    notes.sort(key=lambda n: n.created_at, reverse=True)
    for note in notes:
        tags_str = ', '.join(note.tags) if note.tags else 'No tags'
        print(f'{note.filepath.name} | Title: {note.title} | Tags: {tags_str} | Created: {note.created_at.strftime("%Y-%m-%d %H:%M")}')

def search_notes(query: str):
    ensure_notes_dir()
    if not query.strip():
        logging.error('Search query cannot be empty.')
        return
    query_lower = query.lower()
    matched = []
    for filepath in NOTES_DIR.glob('*.md'):
        try:
            with filepath.open('r', encoding='utf-8') as f:
                content = f.read().lower()
            if query_lower in content:
                note = Note.from_file(filepath)
                matched.append(note)
        except Exception as e:
            logging.error(f'Error reading file: {filepath} - {e}')
            continue
    if not matched:
        logging.info('No matching notes found.')
        return
    matched.sort(key=lambda n: n.created_at, reverse=True)
    for note in matched:
        tags_str = ', '.join(note.tags) if note.tags else 'No tags'
        print(f'{note.filepath.name} | Title: {note.title} | Tags: {tags_str} | Created: {note.created_at.strftime("%Y-%m-%d %H:%M")}')

def main():
    parser = argparse.ArgumentParser(description='Markdown Notes Manager CLI')
    subparsers = parser.add_subparsers(dest='command', required=True)

    create_parser = subparsers.add_parser('create', help='Create a new note')
    create_parser.add_argument('-t', '--title', type=str, required=True, help='Title of the note')
    create_parser.add_argument('--tags', type=str, nargs='*', help='Tags for the note')

    list_parser = subparsers.add_parser('list', help='List notes')
    list_parser.add_argument('--tag', type=str, help='Filter notes by tag')

    search_parser = subparsers.add_parser('search', help='Search notes by text')
    search_parser.add_argument('query', type=str, help='Search query string')

    update_parser = subparsers.add_parser('update', help='Update a note')
    update_parser.add_argument('filename', type=str, help='Filename of the note to update')
    update_parser.add_argument('--title', type=str, help='New title of the note')
    update_parser.add_argument('--tags', type=str, nargs='*', help='New tags for the note')

    delete_parser = subparsers.add_parser('delete', help='Delete a note')
    delete_parser.add_argument('filename', type=str, help='Filename of the note to delete')

    args = parser.parse_args()

    try:
        if args.command == 'create':
            create_note(args.title, args.tags)
        elif args.command == 'list':
            list_notes(args.tag)
        elif args.command == 'search':
            search_notes(args.query)
        elif args.command == 'update':
            filepath = NOTES_DIR / args.filename
            note = Note.from_file(filepath)
            note.update(new_title=args.title, new_tags=args.tags)
        elif args.command == 'delete':
            filepath = NOTES_DIR / args.filename
            note = Note.from_file(filepath)
            note.delete()
        else:
            parser.print_help()
    except Exception as e:
        logging.error(f'Error: {e}')
        sys.exit(1)

if __name__ == '__main__':
    main()